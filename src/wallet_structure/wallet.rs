use super::{account::Account, error_wallet::ErrorWallet};

use crate::{
    configurations::try_default::TryDefault,
    serialization::{
        deserializable_internal_order::DeserializableInternalOrder,
        deserializable_little_endian::DeserializableLittleEndian,
        error_serialization::ErrorSerialization,
        serializable_internal_order::SerializableInternalOrder,
        serializable_little_endian::SerializableLittleEndian,
    },
};

use std::io::{Read, Write};

/// It's the internal representation of a wallet
#[derive(Debug, PartialEq)]
pub struct Wallet {
    selected_account: Option<Account>,
    accounts: Vec<Account>,
}

impl Wallet {
    pub fn new(accounts: Vec<Account>) -> Wallet {
        Wallet {
            selected_account: accounts.first().cloned(),
            accounts,
        }
    }

    /// Appends an account to the wallet
    pub fn add_account(&mut self, account: Account) {
        self.accounts.push(account);
    }

    /// Removes an account from the wallet if it exists
    pub fn remove_account(&mut self, account: Account) {
        self.accounts.retain(|x| x != &account);
        if let None = self.selected_account {
            self.selected_account = self.accounts.first().cloned();
        }
    }

    /// Changes the selected account
    pub fn change_account(&mut self, account: Account) {
        self.selected_account = Some(account);
    }

    /// Returns the selected account from the wallet
    pub fn get_selected_account(&self) -> Option<&Account> {
        self.selected_account.as_ref()
    }

    /// Returns the accounts from the wallet
    pub fn get_accounts(&self) -> &Vec<Account> {
        &self.accounts
    }

    /// Returns an account from the wallet by its name
    pub fn get_account_with_name(&self, name: &str) -> Option<&Account> {
        self.accounts.iter().find(|x| x.account_name == name)
    }
}

impl TryDefault for Wallet {
    type Error = ErrorWallet;

    fn try_default() -> Result<Self, Self::Error> {
        Ok(Wallet::new(Vec::new()))
    }
}

impl SerializableInternalOrder for Wallet {
    fn io_serialize(&self, stream: &mut dyn Write) -> Result<(), ErrorSerialization> {
        (self.accounts.len() as u64).le_serialize(stream)?;

        for account in &self.accounts {
            account.io_serialize(stream)?;
        }

        Ok(())
    }
}

impl DeserializableInternalOrder for Wallet {
    fn io_deserialize(stream: &mut dyn Read) -> Result<Self, ErrorSerialization> {
        let accounts_len = u64::le_deserialize(stream)?;

        let mut accounts: Vec<Account> = Vec::new();
        for _ in 0..accounts_len {
            accounts.push(Account::io_deserialize(stream)?);
        }

        Ok(Wallet::new(accounts))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_01_correct_wallet_creation() {
        let account_old = Account::new(
            "Old",
            &[
                0x0A, 0x52, 0x65, 0x08, 0x2E, 0x24, 0x11, 0x5F, 0x77, 0x54, 0x0A, 0xB3, 0xB8, 0xC2,
                0xB9, 0x20, 0x60, 0xAA, 0x30, 0xD6, 0xD2, 0xB8, 0x1A, 0x08, 0x5D, 0x71, 0xAB, 0x37,
                0xED, 0xA7, 0x68, 0x91,
            ],
            &[
                0x03, 0xBC, 0x6D, 0x45, 0xD2, 0x10, 0x1E, 0x91, 0x28, 0xDE, 0x14, 0xB5, 0xB6, 0x68,
                0x83, 0xD6, 0x9C, 0xF1, 0xC3, 0x1A, 0x50, 0xB9, 0x6F, 0xEA, 0x2D, 0xAD, 0x4E, 0xD2,
                0x35, 0x14, 0x92, 0x4A, 0x22,
            ],
        )
        .unwrap();

        let account_new = Account::new(
            "New",
            &[
                0x0A, 0x52, 0x65, 0x08, 0x2E, 0x24, 0x11, 0x5F, 0x77, 0x54, 0x0A, 0xB3, 0xB8, 0xC2,
                0xB9, 0x20, 0x60, 0xAA, 0x30, 0xD6, 0xD2, 0xB8, 0x1A, 0x08, 0x5D, 0x71, 0xAB, 0x37,
                0xED, 0xA7, 0x68, 0x91,
            ],
            &[
                0x03, 0xBC, 0x6D, 0x45, 0xD2, 0x10, 0x1E, 0x91, 0x28, 0xDE, 0x14, 0xB5, 0xB6, 0x68,
                0x83, 0xD6, 0x9C, 0xF1, 0xC3, 0x1A, 0x50, 0xB9, 0x6F, 0xEA, 0x2D, 0xAD, 0x4E, 0xD2,
                0x35, 0x14, 0x92, 0x4A, 0x22,
            ],
        )
        .unwrap();

        let account_vector = vec![account_old, account_new];
        let wallet = Wallet::new(account_vector);
        assert!(wallet.accounts.len() == 2);
    }

    #[test]
    fn test_02_correct_wallet_serialization() {
        let account_old = Account::new(
            "Old",
            &[
                0x0A, 0x52, 0x65, 0x08, 0x2E, 0x24, 0x11, 0x5F, 0x77, 0x54, 0x0A, 0xB3, 0xB8, 0xC2,
                0xB9, 0x20, 0x60, 0xAA, 0x30, 0xD6, 0xD2, 0xB8, 0x1A, 0x08, 0x5D, 0x71, 0xAB, 0x37,
                0xED, 0xA7, 0x68, 0x91,
            ],
            &[
                0x03, 0xBC, 0x6D, 0x45, 0xD2, 0x10, 0x1E, 0x91, 0x28, 0xDE, 0x14, 0xB5, 0xB6, 0x68,
                0x83, 0xD6, 0x9C, 0xF1, 0xC3, 0x1A, 0x50, 0xB9, 0x6F, 0xEA, 0x2D, 0xAD, 0x4E, 0xD2,
                0x35, 0x14, 0x92, 0x4A, 0x22,
            ],
        )
        .unwrap();

        let account_new = Account::new(
            "New",
            &[
                0x0A, 0x52, 0x65, 0x08, 0x2E, 0x24, 0x11, 0x5F, 0x77, 0x54, 0x0A, 0xB3, 0xB8, 0xC2,
                0xB9, 0x20, 0x60, 0xAA, 0x30, 0xD6, 0xD2, 0xB8, 0x1A, 0x08, 0x5D, 0x71, 0xAB, 0x37,
                0xED, 0xA7, 0x68, 0x91,
            ],
            &[
                0x03, 0xBC, 0x6D, 0x45, 0xD2, 0x10, 0x1E, 0x91, 0x28, 0xDE, 0x14, 0xB5, 0xB6, 0x68,
                0x83, 0xD6, 0x9C, 0xF1, 0xC3, 0x1A, 0x50, 0xB9, 0x6F, 0xEA, 0x2D, 0xAD, 0x4E, 0xD2,
                0x35, 0x14, 0x92, 0x4A, 0x22,
            ],
        )
        .unwrap();

        let account_vector = vec![account_old.clone(), account_new.clone()];
        let wallet = Wallet::new(account_vector.clone());

        let mut serialized_fields = Vec::new();
        (account_vector.len() as u64)
            .le_serialize(&mut serialized_fields)
            .unwrap();
        account_old.io_serialize(&mut serialized_fields).unwrap();
        account_new.io_serialize(&mut serialized_fields).unwrap();

        let mut serialized_wallet = Vec::new();
        wallet.io_serialize(&mut serialized_wallet).unwrap();

        assert_eq!(serialized_fields, serialized_wallet);
    }

    #[test]
    fn test_03_correct_wallet_deserialization() {
        let account_old = Account::new(
            "Old",
            &[
                0x0A, 0x52, 0x65, 0x08, 0x2E, 0x24, 0x11, 0x5F, 0x77, 0x54, 0x0A, 0xB3, 0xB8, 0xC2,
                0xB9, 0x20, 0x60, 0xAA, 0x30, 0xD6, 0xD2, 0xB8, 0x1A, 0x08, 0x5D, 0x71, 0xAB, 0x37,
                0xED, 0xA7, 0x68, 0x91,
            ],
            &[
                0x03, 0xBC, 0x6D, 0x45, 0xD2, 0x10, 0x1E, 0x91, 0x28, 0xDE, 0x14, 0xB5, 0xB6, 0x68,
                0x83, 0xD6, 0x9C, 0xF1, 0xC3, 0x1A, 0x50, 0xB9, 0x6F, 0xEA, 0x2D, 0xAD, 0x4E, 0xD2,
                0x35, 0x14, 0x92, 0x4A, 0x22,
            ],
        )
        .unwrap();

        let account_new = Account::new(
            "New",
            &[
                0x0A, 0x52, 0x65, 0x08, 0x2E, 0x24, 0x11, 0x5F, 0x77, 0x54, 0x0A, 0xB3, 0xB8, 0xC2,
                0xB9, 0x20, 0x60, 0xAA, 0x30, 0xD6, 0xD2, 0xB8, 0x1A, 0x08, 0x5D, 0x71, 0xAB, 0x37,
                0xED, 0xA7, 0x68, 0x91,
            ],
            &[
                0x03, 0xBC, 0x6D, 0x45, 0xD2, 0x10, 0x1E, 0x91, 0x28, 0xDE, 0x14, 0xB5, 0xB6, 0x68,
                0x83, 0xD6, 0x9C, 0xF1, 0xC3, 0x1A, 0x50, 0xB9, 0x6F, 0xEA, 0x2D, 0xAD, 0x4E, 0xD2,
                0x35, 0x14, 0x92, 0x4A, 0x22,
            ],
        )
        .unwrap();

        let account_vector = vec![account_old, account_new];
        let wallet = Wallet::new(account_vector);

        let mut serialized_wallet = Vec::new();
        wallet.io_serialize(&mut serialized_wallet).unwrap();

        let deserialized_wallet =
            Wallet::io_deserialize(&mut serialized_wallet.as_slice()).unwrap();

        assert_eq!(wallet, deserialized_wallet);
    }

    #[test]
    fn test_04_correct_account_appending() {
        let account_old = Account::new(
            "Old",
            &[
                0x0A, 0x52, 0x65, 0x08, 0x2E, 0x24, 0x11, 0x5F, 0x77, 0x54, 0x0A, 0xB3, 0xB8, 0xC2,
                0xB9, 0x20, 0x60, 0xAA, 0x30, 0xD6, 0xD2, 0xB8, 0x1A, 0x08, 0x5D, 0x71, 0xAB, 0x37,
                0xED, 0xA7, 0x68, 0x91,
            ],
            &[
                0x03, 0xBC, 0x6D, 0x45, 0xD2, 0x10, 0x1E, 0x91, 0x28, 0xDE, 0x14, 0xB5, 0xB6, 0x68,
                0x83, 0xD6, 0x9C, 0xF1, 0xC3, 0x1A, 0x50, 0xB9, 0x6F, 0xEA, 0x2D, 0xAD, 0x4E, 0xD2,
                0x35, 0x14, 0x92, 0x4A, 0x22,
            ],
        )
        .unwrap();

        let account_new = Account::new(
            "New",
            &[
                0x0A, 0x52, 0x65, 0x08, 0x2E, 0x24, 0x11, 0x5F, 0x77, 0x54, 0x0A, 0xB3, 0xB8, 0xC2,
                0xB9, 0x20, 0x60, 0xAA, 0x30, 0xD6, 0xD2, 0xB8, 0x1A, 0x08, 0x5D, 0x71, 0xAB, 0x37,
                0xED, 0xA7, 0x68, 0x91,
            ],
            &[
                0x03, 0xBC, 0x6D, 0x45, 0xD2, 0x10, 0x1E, 0x91, 0x28, 0xDE, 0x14, 0xB5, 0xB6, 0x68,
                0x83, 0xD6, 0x9C, 0xF1, 0xC3, 0x1A, 0x50, 0xB9, 0x6F, 0xEA, 0x2D, 0xAD, 0x4E, 0xD2,
                0x35, 0x14, 0x92, 0x4A, 0x22,
            ],
        )
        .unwrap();

        let account_vector = vec![account_old];
        let mut wallet = Wallet::new(account_vector);

        assert_eq!(wallet.accounts.len(), 1);
        wallet.add_account(account_new);
        assert_eq!(wallet.accounts.len(), 2);
    }

    #[test]
    fn test_05_get_account_with_name() {
        let account_old = Account::new(
            "Old",
            &[
                0x0A, 0x52, 0x65, 0x08, 0x2E, 0x24, 0x11, 0x5F, 0x77, 0x54, 0x0A, 0xB3, 0xB8, 0xC2,
                0xB9, 0x20, 0x60, 0xAA, 0x30, 0xD6, 0xD2, 0xB8, 0x1A, 0x08, 0x5D, 0x71, 0xAB, 0x37,
                0xED, 0xA7, 0x68, 0x91,
            ],
            &[
                0x03, 0xBC, 0x6D, 0x45, 0xD2, 0x10, 0x1E, 0x91, 0x28, 0xDE, 0x14, 0xB5, 0xB6, 0x68,
                0x83, 0xD6, 0x9C, 0xF1, 0xC3, 0x1A, 0x50, 0xB9, 0x6F, 0xEA, 0x2D, 0xAD, 0x4E, 0xD2,
                0x35, 0x14, 0x92, 0x4A, 0x22,
            ],
        )
        .unwrap();

        let account_new = Account::new(
            "New",
            &[
                0x0A, 0x52, 0x65, 0x08, 0x2E, 0x24, 0x11, 0x5F, 0x77, 0x54, 0x0A, 0xB3, 0xB8, 0xC2,
                0xB9, 0x20, 0x60, 0xAA, 0x30, 0xD6, 0xD2, 0xB8, 0x1A, 0x08, 0x5D, 0x71, 0xAB, 0x37,
                0xED, 0xA7, 0x68, 0x91,
            ],
            &[
                0x03, 0xBC, 0x6D, 0x45, 0xD2, 0x10, 0x1E, 0x91, 0x28, 0xDE, 0x14, 0xB5, 0xB6, 0x68,
                0x83, 0xD6, 0x9C, 0xF1, 0xC3, 0x1A, 0x50, 0xB9, 0x6F, 0xEA, 0x2D, 0xAD, 0x4E, 0xD2,
                0x35, 0x14, 0x92, 0x4A, 0x22,
            ],
        )
        .unwrap();

        let account_vector = vec![account_old.clone(), account_new];
        let wallet = Wallet::new(account_vector);

        let old_gotten = wallet.get_account_with_name("Old").unwrap();

        assert_eq!(old_gotten.account_name, account_old.account_name);
    }

    #[test]
    fn test_06_correct_account_deletion() {
        let account_old = Account::new(
            "Old",
            &[
                0x0A, 0x52, 0x65, 0x08, 0x2E, 0x24, 0x11, 0x5F, 0x77, 0x54, 0x0A, 0xB3, 0xB8, 0xC2,
                0xB9, 0x20, 0x60, 0xAA, 0x30, 0xD6, 0xD2, 0xB8, 0x1A, 0x08, 0x5D, 0x71, 0xAB, 0x37,
                0xED, 0xA7, 0x68, 0x91,
            ],
            &[
                0x03, 0xBC, 0x6D, 0x45, 0xD2, 0x10, 0x1E, 0x91, 0x28, 0xDE, 0x14, 0xB5, 0xB6, 0x68,
                0x83, 0xD6, 0x9C, 0xF1, 0xC3, 0x1A, 0x50, 0xB9, 0x6F, 0xEA, 0x2D, 0xAD, 0x4E, 0xD2,
                0x35, 0x14, 0x92, 0x4A, 0x22,
            ],
        )
        .unwrap();

        let account_new = Account::new(
            "New",
            &[
                0x0A, 0x52, 0x65, 0x08, 0x2E, 0x24, 0x11, 0x5F, 0x77, 0x54, 0x0A, 0xB3, 0xB8, 0xC2,
                0xB9, 0x20, 0x60, 0xAA, 0x30, 0xD6, 0xD2, 0xB8, 0x1A, 0x08, 0x5D, 0x71, 0xAB, 0x37,
                0xED, 0xA7, 0x68, 0x91,
            ],
            &[
                0x03, 0xBC, 0x6D, 0x45, 0xD2, 0x10, 0x1E, 0x91, 0x28, 0xDE, 0x14, 0xB5, 0xB6, 0x68,
                0x83, 0xD6, 0x9C, 0xF1, 0xC3, 0x1A, 0x50, 0xB9, 0x6F, 0xEA, 0x2D, 0xAD, 0x4E, 0xD2,
                0x35, 0x14, 0x92, 0x4A, 0x22,
            ],
        )
        .unwrap();

        let account_vector = vec![account_old.clone(), account_new];
        let mut wallet = Wallet::new(account_vector);

        wallet.remove_account(account_old);

        assert!(wallet.get_account_with_name("Old").is_none());
    }
}
